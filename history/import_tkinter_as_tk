[{"role": "user", "content": "import tkinter as tk\nfrom tkinter import scrolledtext, filedialog, Menu, Listbox, Button, PanedWindow\nimport tkinter.font as tkfont\nimport openai\nimport json\nimport os\nimport re\n\n# Initialize global variables\napi_key_window = None\napi_key_entry = None\n\n# Define the system message\nsystem_message = \"You are a friendly chatbot.\"\n\n# Initialize the conversation history\nconversation = []\n\n# Counter for conversation file names\nfile_counter = 1\n\n# Define file_listbox and chat_log as global variables\nfile_listbox = None\nchat_log = None\n\n# Define a variable to store the current loaded file name\ncurrent_loaded_file = None\n\n# Store filenames (including extensions) in a list\nfile_list = []\n\ndef code_system_message():\n    global system_message\n    # Update the system message to \"hello\"\n    system_message = \"Breakdown the submitted code\"\n    send_message(entry)  # Send the prompt with the updated system message\n\ndef joke_system_message():\n    global system_message\n    # Update the system message to \"hello\"\n    system_message = \"Tell a joke\"\n    send_message(entry)  # Send the prompt with the updated system message\n\n\n# Function to send a message when Ctrl-Enter is pressed and without a new line\ndef send_message_on_ctrl_enter(event):\n    if event.state == 4:  # Check if the Ctrl key is held down (Ctrl modifier has state 4)\n        send_message(entry)\n        return 'break'  # This prevents the default newline behavior\n\ndef set_api_key():\n    api_key = api_key_entry.get()\n    openai.api_key = api_key\n    api_key_window.destroy()\n    initialize_chat_window()\n\ndef send_message(entry):\n    global chat_log, conversation\n\n    user_message = entry.get(\"1.0\", tk.END).strip()\n    entry.delete(\"1.0\", tk.END)\n\n# Initialize the conversation history with the system message\n    conversation.append({\"role\": \"system\", \"content\": system_message})\n    conversation.append({\"role\": \"user\", \"content\": user_message})\n\n    chat_log.config(state=tk.NORMAL)\n    chat_log.insert(tk.END, f\"You: {user_message}\\n\", \"user\")\n    chat_log.config(state=tk.DISABLED)\n\n    completion = openai.ChatCompletion.create(\n        model=\"gpt-3.5-turbo\",\n        messages=conversation\n    )\n\n    ai_response = completion['choices'][0]['message']['content']\n\n    conversation.append({\"role\": \"assistant\", \"content\": ai_response})\n\n    update_chat_log()\n\n\ndef regenerate_response():\n    global chat_log, conversation\n\n    if conversation:\n        conversation.pop()\n\n        completion = openai.ChatCompletion.create(\n            model=\"gpt-3.5-turbo\",\n            messages=conversation\n        )\n\n        ai_response = completion['choices'][0]['message']['content']\n\n        conversation.append({\"role\": \"assistant\", \"content\": ai_response})\n\n        update_chat_log()\n\n# Function to sanitize a string for use as a filename\ndef sanitize_filename(filename):\n    # Remove non-alphanumeric characters, spaces, and newlines\n    sanitized_filename = re.sub(r'[^\\w\\s-]', '', filename)\n    sanitized_filename = sanitized_filename.replace(' ', '_')\n    sanitized_filename = sanitized_filename.replace('\\n', '')\n\n    # Truncate to the first 20 characters\n    return sanitized_filename[:20]\n\n# Function to save a conversation\ndef save_conversation():\n    global conversation\n\n    if not conversation:\n        return  # Do nothing if the conversation is empty\n\n    user_message = conversation[1][\"content\"]\n\n    # Specify the subfolder \"history\" as part of the file path\n    history_subfolder = \"history\"\n    if not os.path.exists(history_subfolder):\n        os.makedirs(history_subfolder)\n\n    # Sanitize the user_message for use as a filename\n    sanitized_user_message = sanitize_filename(user_message)\n\n    # Use the sanitized user_message as the filename without an extension\n    filename = sanitized_user_message\n\n    # Specify the file path within the \"history\" subfolder\n    file_path = os.path.join(history_subfolder, filename)\n\n    # Check if the file already exists; if yes, increment the filename\n    counter = 1\n    while os.path.exists(file_path):\n        filename = f\"{sanitized_user_message}_{counter}\"\n        file_path = os.path.join(history_subfolder, filename)\n        counter += 1\n\n    with open(file_path, 'w') as file:\n        json.dump(conversation[1:], file)\n    update_file_listbox()  # Update the listbox after saving\n\n\ndef load_conversation(file_path):\n    global conversation\n\n    with open(file_path, 'r') as file:\n        conversation = json.load(file)\n\ndef load_conversation_from_file(filename):\n    global conversation\n\n    if filename:\n        # Specify the subfolder \"history\" as part of the file path\n        file_path = os.path.join(\"history\", filename)\n        conversation = []  # Clear existing conversation\n        load_conversation(file_path)\n        update_chat_log()\n\ndef delete_json_file(filename):\n    global file_list\n\n    # Specify the subfolder \"history\" as part of the file path\n    file_path = os.path.join(\"history\", filename)\n    \n    try:\n        os.remove(file_path)\n        # Remove the deleted filename from the file_list\n        if filename in file_list:\n            file_list.remove(filename)\n        update_file_listbox()\n    except FileNotFoundError:\n        # Handle the case where the file does not exist\n        print(f\"File '{filename}' not found.\")\n    except Exception as e:\n        # Handle other exceptions that might occur during file deletion\n        print(f\"An error occurred while deleting '{filename}': {str(e)}\")\n\ndef update_chat_log():\n    global chat_log, conversation\n\n    chat_log.config(state=tk.NORMAL)\n    chat_log.delete(\"1.0\", tk.END)\n    for message in conversation:\n        if message[\"role\"] == \"user\":\n            chat_log.insert(tk.END, f\"You: {message['content']}\\n\", \"user\")\n        elif message[\"role\"] == \"assistant\":  # Only display assistant's messages\n            chat_log.insert(tk.END, f\"AI: {message['content']}\\n\", \"assistant\")\n    chat_log.config(state=tk.DISABLED)\n    chat_log.see(tk.END)\n\ndef update_file_listbox():\n    global file_listbox, file_list\n\n    # Clear the current listbox items\n    file_listbox.delete(0, tk.END)\n\n    # Specify the subfolder \"history\" as part of the file path\n    history_subfolder = os.path.join(os.getcwd(), \"history\")\n\n    # List all files in the \"history\" subfolder\n    file_list = [filename for filename in os.listdir(history_subfolder)]\n\n    # Add filenames (including extensions) to the Listbox\n    for filename in file_list:\n        file_listbox.insert(tk.END, filename)\n\ndef start_new_check():\n    global conversation, current_loaded_file\n\n    if conversation:\n        save_conversation()\n\n    conversation.clear()\n    current_loaded_file = None  # Clear the current loaded file name\n    chat_log.config(state=tk.NORMAL)\n    chat_log.delete(\"1.0\", tk.END)\n    chat_log.config(state=tk.DISABLED)\n\ndef initialize_chat_window():\n    global chat_log, entry, file_listbox, conversation\n\n    root = tk.Tk()\n    root.title(\"OpenAI Brendenbot\")\n\n    file_frame = tk.Frame(root, width=200)\n    file_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n\n    # Create the Listbox with grey background, white text, and Arial font\n    listbox_font = tkfont.Font(family=\"Arial\", size=12)\n    global file_listbox\n    file_listbox = Listbox(file_frame, bg=\"gray\", fg=\"white\", font=listbox_font)\n    file_listbox.pack(fill=tk.BOTH, expand=True)\n    update_file_listbox()\n\n    def load_selected_conversation():\n        selected_index = file_listbox.curselection()\n        if selected_index:\n            selected_filename = file_listbox.get(selected_index[0])  # Get the selected filename\n            load_conversation_from_file(selected_filename)\n\n    save_button = Button(file_frame, text=\"Save Conversation\", command=save_conversation)\n    save_button.pack(fill=tk.BOTH)\n\n    load_button = Button(file_frame, text=\"Load Conversation\", command=load_selected_conversation)\n    load_button.pack(fill=tk.BOTH)\n\n    def delete_selected_file():\n        selected_index = file_listbox.curselection()\n        if selected_index:\n            selected_filename = file_listbox.get(selected_index[0])  # Get the selected filename\n            delete_json_file(selected_filename)\n\n    # Create a \"Delete File\" button\n    delete_button = Button(file_frame, text=\"Delete File\", command=delete_selected_file)\n    delete_button.pack(fill=tk.BOTH)\n\n    menu = Menu(root)\n    root.config(menu=menu)\n    conversation_menu = Menu(menu)\n    menu.add_cascade(label=\"Conversation\", menu=conversation_menu)\n    conversation_menu.add_command(label=\"Load File\", command=load_selected_conversation)\n    conversation_menu.add_command(label=\"Delete Selected File\", command=delete_selected_file)\n    conversation_menu.add_separator()\n    conversation_menu.add_command(label=\"Exit\", command=root.destroy)\n\n    chat_log = scrolledtext.ScrolledText(root, state=tk.DISABLED, wrap=tk.WORD, bg=\"light green\", fg=\"black\")\n    chat_log.pack(expand=True, fill=\"both\")\n\n    user_font = tkfont.Font(family=\"Arial\", size=12, weight=\"bold\")\n    assistant_font = tkfont.Font(family=\"Arial\", size=12, slant=\"italic\")\n\n    chat_log.tag_configure(\"user\", justify='left', foreground='white', font=user_font)\n    chat_log.tag_configure(\"assistant\", justify='left', foreground='black', font=assistant_font)\n\n    entry = tk.Text(root, height=5)\n    entry.pack(expand=True, fill=\"both\", padx=10, pady=10)\n    entry.focus_set()\n\n    h_scrollbar = tk.Scrollbar(entry, orient=tk.HORIZONTAL)\n    v_scrollbar = tk.Scrollbar(entry, orient=tk.VERTICAL)\n    entry.config(xscrollcommand=h_scrollbar.set, yscrollcommand=v_scrollbar.set)\n    h_scrollbar.config(command=entry.xview)\n    v_scrollbar.config(command=entry.yview)\n    h_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)\n    v_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n\n    regenerate_button = Button(root, text=\"Regenerate\", font=user_font, command=regenerate_response)\n    regenerate_button.pack(side=tk.LEFT)\n\n    code_system_button = Button(root, text=\"Code Breakdown\", font=user_font, command=code_system_message)\n    code_system_button.pack(side=tk.LEFT)\n\n    joke_system_button = Button(root, text=\"Joke Bot\", font=user_font, command=joke_system_message)\n    joke_system_button.pack(side=tk.LEFT)\n\n    new_check_button = Button(root, text=\"New Chat\", font=user_font, command=start_new_check)\n    new_check_button.pack(side=tk.RIGHT)\n\n    send_button = Button(root, text=\"   Send   \", font=user_font, command=lambda: send_message(entry))\n    send_button.pack(side=tk.BOTTOM, fill=tk.X)\n\n    # Bind Ctrl-Enter to send_message_on_ctrl_enter\n    entry.bind('<Control-Return>', send_message_on_ctrl_enter)\n\n    # Set the system message to \"You are a friendly chatbot\"\n    #conversation.append({\"role\": \"system\", \"content\": \"You are a friendly chatbo\"})\n\n    root.mainloop()\n\n# Function to handle Enter key in the API key entry\ndef handle_api_key_entry(event):\n    set_api_key()\n\n# Initialize the API key input window\ndef initialize_api_key_window():\n    global api_key_window, api_key_entry\n\n    api_key_window = tk.Tk()\n    api_key_window.title(\"API Key Input\")\n\n    api_key_label = tk.Label(api_key_window, text=\"Enter your OpenAI API key:\")\n    api_key_label.pack()\n\n    api_key_entry = tk.Entry(api_key_window)\n    api_key_entry.pack()\n    api_key_entry.focus_set()\n\n    api_key_button = tk.Button(api_key_window, text=\"Set API Key\", command=set_api_key)\n    api_key_button.pack()\n\n    # Bind Enter key to handle_api_key_entry\n    api_key_entry.bind('<Return>', handle_api_key_entry)\n\n    api_key_window.mainloop()\n\n# Initialize the API key input window\ninitialize_api_key_window()"}, {"role": "assistant", "content": "The code is a Python script that creates a chatbot using the Tkinter library for GUI. It uses the OpenAI API to generate responses for user inputs.\n\nThe code starts by importing the necessary modules and packages. Then, it initializes some global variables and defines a system message, conversation history, file-related variables, and an API key window.\n\nThere are two functions defined to update the system message to \"Code Breakdown\" or \"Tell a Joke\" and send a message when the Ctrl-Enter key combination is pressed without a new line.\n\nThe `set_api_key()` function is used to set the OpenAI API key and initialize the chat window. It retrieves the API key from the entry widget and sets it as the `openai.api_key`.\n\nThe `send_message(entry)` function is responsible for sending a message. It gets the user's message from the entry widget, adds it to the conversation history, and sends it to the OpenAI Chat API for response generation. It updates the chat log with the user's message and the generated AI response.\n\nThe `regenerate_response()` function is used to regenerate the AI response. It removes the last AI response from the conversation history and sends the updated conversation to the OpenAI Chat API for generating a new AI response. It then updates the chat log with the new AI response.\n\nThe `sanitize_filename(filename)` function is used to sanitize a string to be used as a filename. It removes non-alphanumeric characters, spaces, and newlines from the filename and truncates it to the first 20 characters.\n\nThe `save_conversation()` function is used to save the conversation history to a JSON file. It first checks if the conversation is empty and returns if so. Otherwise, it retrieves the user's message from the conversation history, sanitizes it as a filename, and creates the file path. If the file already exists, it increments the filename. It then saves the conversation history (excluding the system message) to the JSON file and updates the file listbox.\n\nThe `load_conversation(file_path)` function is used to load a conversation from a JSON file. It opens the file and loads the conversation history from it.\n\nThe `load_conversation_from_file(filename)` function is used to load a conversation from a file name. It constructs the file path and calls the `load_conversation()` function.\n\nThe `delete_json_file(filename)` function is used to delete a JSON file. It constructs the file path and removes the file. It also removes the filename from the file list and updates the file listbox.\n\nThe `update_chat_log()` function is used to update the chat log with the conversation history. It clears the current chat log, iterates over the conversation history, and inserts the user's messages as \"You:\" and the assistant's messages as \"AI:\" into the chat log.\n\nThe `update_file_listbox()` function is used to update the file listbox with the filenames in the \"history\" subfolder. It clears the current listbox items and adds the filenames to the listbox.\n\nThe `start_new_check()` function is used to start a new conversation. It saves the current conversation if it exists, clears the conversation history and the current loaded file name, and clears the chat log.\n\nThe `initialize_chat_window()` function is used to initialize the chat window. It creates a window using the Tkinter library and adds various widgets to it, such as the file listbox, save/load/delete buttons, chat log, user input entry, scrollbars, regenerate button, code breakdown/joke bot buttons, and new chat/send buttons. It also sets the event handlers for Ctrl-Enter key combination and button clicks. It then sets the system message to \"You are a friendly chatbot\" and starts the Tkinter main loop.\n\nThe `handle_api_key_entry(event)` function is used to handle the Enter key in the API key entry. It calls the `set_api_key()` function.\n\nFinally, the script initializes the API key input window by calling the `initialize_api_key_window()` function.\n\nOverall, the code sets up a chatbot interface using Tkinter and handles user interactions to send messages, generate AI responses, save/load/delete conversations, and display the conversation history."}]